## 一.多态
#### 1.理解
- 事物存在的多种体现形态
> Cat x = new Cat（）；

> Animal x = new Cat（）；   

#### 2.多态的体现
- 父类的引用指向了自己的子类对象，（动物是猫的父类型）；
- 父类的引用也可以接收自己的子类对象

#### 2.多态的前提
- 必须是类与类之间有关系，要么继承，要么实现；
- 通常还有一个前提：存在覆盖；

#### 3.多态的好处
- 多态的出现大大地提高程序的扩展性

#### 4.多态的弊端
- 只能使用父类的引用访问父类的成员；

#### 5.多态的应用

#### 6.多态的出现代码中的特点（多态使用的注意事项）
###### 6.1父类指向子类对象时：
- 编译时期：参阅引用型变量所属的类（父类）中是否有调用的方法，
有则编译通过，否则编译失败；
- 运行时期：参阅对象所属的类（子类）中是否有调用的方法
- 总结：成员函数在多态调用时，编译看左边，运行看右边；

###### 6.2成员变量的特点
- 无论编译和运行，都参考左边（引用型变量所属的类）；

###### 6.3多态中静态成员函数的特点
- 无论编译和运行，都参考左边；

#### 7.转型
- 类型提升，向上转型
> Animal x = new Cat（）；     

- 若想调用猫的特有方法：强制将父类的引用，转成子类类型，向下转型
> Cat c = (Cat)x;
> 
> x.catchMouse();

- 不能将父类对象转成子类类型，自始至终都是子类对象在做着变化；

#### 8.判断指定对象是否属于指定类
- if(duixiang ==instanceof== lei)

## 二.object类
#### 1.==equals（）==
- object：是所有对象直接或间接的父类;
- equals（）:比较两对象是否相等的方法；
> d1.equals(d2)--->true/false

- **注意**
> object 类中已经提供了对对象是否相同的比较方法；
> 
> 如果自定义类中也有比较相同的功能。没有必要重新定义；
> 
> 只要沿袭父类中的功能，建立自己特有的比较内容即可；（即覆盖）

- **代码示例**

class Demo

{
    
    private int num;
    Demo(int num)
    {
        this.num = num;
    }
    
    public boolean equals(object obj)
    {
        if(!(obj instanceof Demo))
        return false;
        Demo d = (Demo)obj;
        return this.num == d.num;
    }
}

#### 2.toString()



