## 一.继承

#### 1.格式
class Student ==extends== Person

#### 2.作用
- 提高了代码的复用性
- 让类与类之间产生了关系； 有了这个关系，才有了多态的特性；

#### 3.注意
- 类与类之间有所属关系才可以继承
- java只支持单继承，不支持多继承（不 一继承多）；支持多层继承

#### 4.多层继承
- ==具体调用时要创建最子类的对象==
- 查阅父类功能，创建子类对象使用功能；

#### 5.子父类中类成员的特点
##### 5.1.变量
子父类中出现非私有的同名变量时，

- 子类要访问本类中的变量，用this；
- 子类要访问父类中的同名变量，用super；

==super==的使用和this的使用几乎一致
- this：本类对象的引用
- super：父类对象的引用

##### 5.2.函数
###### **5.2.1.覆盖（重写）**
子类出现和父类一模一样的函数时，当子类对象调用该函数，会运行子类函数的内容，如同父类函数被覆盖；
- 此时子类虽沿袭了父类功能，但功能内容却不一致，
- 没有必要定义新功能，而使用覆盖特性，保留父类功能定义，子类重写功能内容；

###### **5.2.2.注意**

- ==子类覆盖父类，必须保证子类权限大于等于父类权限==，否则编译失败；
- 静态只能覆盖静态；

###### **5.3.3.记住**

- 重载：只看同名函数的参数列表；
- 重写：子父类方法要一模一样；

## 二.==final==关键字

- 最终。作为一个修饰符；  可以修饰类、函数、变量；
#### 1.类
- 被final修饰的类不可以被继承，避免了被子类复写功能；
> final class Demo{}
#### 2.函数
- 被final修饰的方法不可以被复写；

> final void show(){}
#### 3.变量
- 被final修饰的变量（包括成员变量和局部变量）是一个常量，只能赋值一次；
- （应用在数据的出现值固定时，便于阅读）

> public static final double MY_PI = 3.14;

## 三.抽象类
- 当多个类中出现相同功能，但功能主题不同时，进行向上抽取；  
只抽取功能定义而不抽取功能主体；

#### 1.关键字==abstract== 
#### 2.特点
- 抽象方法一定在抽象类中；
- 抽象方法和抽象类都必须被abstract关键字修饰；
- 抽象类不可以用new创建对象，因调用抽象方法无意义；
- 抽象类中的抽象方法要被使用，必须由子类复写起==所有的==抽象方法后，建立子类对象调用；

> 若子类只覆盖部分抽象方法，则该子类还是一个抽象类；

### 四.模板方法模式
**模板方法**：在定义功能时，功能的一部分时确定的，但有一部分是不确定的，而确定的部分在使用不确定的部分；
这时就将不确定的部分暴露出去，由该类的子类去完成。

## 五.接口
#### 1.格式
- ==interface== Demo {}
> class用于定义类；
> interface用于定义接口

当抽象类中的方法都是抽象的，该类可通过接口的形式来表示；

#### 2.接口中的成员修饰符是固定的
- 成员常量：public static final
- 成员函数：public abstract
> 接口中的成员都是public
#### 3.特点;

- 接口是不可以创建对象的，因为有抽象方法；
- 需要被子类实现，子类对接口中的抽象方法全都覆盖后，子类才可以实例化；   否则子类是一个抽象类
- 类与接口是实现关系，一个类可以继承一个类的同时实现多个接口
- 接口之间可以有继承关系（可多继承）；
- 降低了耦合性；
- 提高功能扩展性（父类是主体，接口是扩展）；

#### 4.接口的出现将"多继承"通过另一种形式体现出来，即"多==实现==";

- 格式：class Test ==implements== Demo
{ }






